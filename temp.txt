#!/usr/bin/env pwsh
#
# This script is meant for quick & easy install on Windows via an elevated command prompt:
#
# PS>Invoke-WebRequest -Uri get.mirantis.com/install.ps1
# PS>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process
# PS>.\install.ps1
#
# To obtain explicit versions of the script, append version number after replacing
# '.' and '-' characters in version with '_':
#
# PS>Invoke-WebRequest -Uri https://get.mirantis.com/install_1_0_5.ps1 -o install.ps1
#
# For more usage information run:
#
# PS>Get-Help .\install.ps1
#
# Copyright Mirantis Inc
#
# Script build information:
# COMMIT_SHA=6ad8439c9a367155520e6d364e6d09fe13a4f89a
# COMMIT_SHA_PVAL=6ad8439
# SEMVER_VERSION=1.0.27
# PUBLISH_STRING=stable
#

<#
.SYNOPSIS

Installs required binaries for UCP install

.DESCRIPTION

The install.ps1 script installs DockerEE and containerd
binaries and services to the local machine.

The script has inbuilt-defaults for everything and can be run
without specifying any values. Script parameters and env
variables can be used to overrule the default values.
Parameter values take precedence over env variables.
Both take precedence over inbuilt default values.

The script needs to be executed from an elevated command prompt.
Should you want to change the default daemon configs, you may
want to have the alternative configurations and the related
collateral in-place before executing the script. For example
if you would like to enable TLS with docker, please make sure
that the certificates are stored appropriately and the daemon
configuration file is written before invoking the script.

.PARAMETER DownloadUrl
[Alternately specified by $Env:DOWNLOAD_URL]
Specify an alternative repository to download container runtime
packages. Please consult the Mirantis product installation
documentation for air-gapped installs to learn more about setting
up a repository mirror.

.PARAMETER Channel
[Alternately specified by $Env:CHANNEL]
Specifies the channel to be used for picking the binaries.
Examples of channels are: stable, test etc. The default channel is
stable-25.0/fips if Windows is configured to run in FIPS mode, otherwise
the default channel is stable-25.0.

.PARAMETER DockerVersion
[Alternately specified by $Env:DOCKER_VERSION]
Specifies the version number for the DockerEE binaries to install.
Latest is used as the default version.

.PARAMETER ContainerdVersion
[Alternately specified by $Env:CONTAINERD_VERSION]
Specifies the version number for the containerd binaries to install
Latest is used as the default version.

.PARAMETER DryRun
If specified, list different steps that would be used
without actually invoking them.

.PARAMETER Uninstall
If specified, uninstalls all packages. This entails
unregistering the corresponding services and removing paths
for the package from the registry.
All other script parameters (except DryRun and DestPath) are
ignored if this switch is specified. Common parameters such
as -Verbose are still honored.

.PARAMETER Ver
Print version info for the script and exit

.PARAMETER NoServiceStarts
If specified, services are not started on successful install.
By default, all services installed by the script are
left in a running state before exit.

.PARAMETER DestPath
Path to the directory under which binaries will be installed.
By default, this path is %PROGRAMFILES%

.PARAMETER OfflinePackagesPath
The folder for airgap/offline scenarios. For use when the
offline or DownloadOnly parameters are specified. Used to
either save the downloaded packages for later offline use
or for pointing to previously downloaded packages for
offline install.

.PARAMETER Offline
Install packages in offline/airgap mode. By default the
current directory will be used to look for previously
downloaded packages. That can be overridden by using
the OfflinePackagesPath parameter.

.PARAMETER DownloadOnly
Download and save packages for later offline/airgap install

.PARAMETER EngineOnly
Skip all steps except those related to Docker EE engine

.PARAMETER ShowVersions
Display a list of all available versions for each package
with the specified Download URL and Channel. Can be used to
determine the version number to use when you want to specify
an explicit version number at install time.

.INPUTS

None. You cannot pipe objects to install.ps1.

.OUTPUTS

None. install.ps1 does not generate any output.

.EXAMPLE

PS> .\install.ps1

.EXAMPLE

PS> .\install.ps1 -Verbose

.NOTES
1. In scenarios where you have existing installed software that has its own
   copies of OpenSSL libraries, you may run into the following error:

OpenSSL error: error:0F06D065:common libcrypto routines:FIPS_mode_set:fips mode not supported

This is often hit if you have ming/mingw64 as a part of your PATH env
variable. To work around this, ensure that the offending software is
not on the PATH and run the script again.

2. The script supports airgap functionality by providing access to
   download packages while online as well as to install those selfsame
   packages while offline.

   For downloads, please ensure that the script has access to the internet.
   Use the -DownloadOnly parameter. By default the script will use the
   current directory to store the packages after download. This can be
   changed by specifying the path explicitly with the -OfflinePackagesPath
   parameter.

   For offline/airgap install, please use the -Offline parameter. By default
   the script will look for pacakage in the current directory. This can be
   changed by specifying the -OfflinePackagesPath parameter.

   While downloading using -DownloadOnly parameter, make sure that the
   download path is accessible to the script, especially if you run the
   script without administrative rights.

#>

# The following is required so that the script can be invoked with named
# parameters (e.g. -ContainerdVersion 1.3.4...). If a parameter is used;
# its type is checked by powershell - we give a higher precedence to the
# parameters specified this way vs. the same value specified by env vars.

# Parameters gotten at invocation time. Some of these values are "merged"
# with values specified by env vars - see reconcileParams. Others are
# used as-is.

[CmdletBinding(PositionalBinding=$FALSE)]
param (
        [string]$DownloadUrl,                # Pointer to CDN for the package zip files.
        [string]$Channel,                    #
        [string]$DockerVersion,              #
        [string]$ContainerdVersion,          #

        [switch]$DryRun,                     # Gives an overview of what would happen on invoking the script. Is
                                             # idempotent - can be run repeatedly without impacting system state.
        [switch]$Uninstall,                  # Uninstall all installed packages
        [switch]$Ver,                        # Print version Info and exit
        [switch]$NoServiceStarts,            # Do not start the services at the end. Useful if certificates need to be
                                             # used or config needs to be built before starting one or more daemons.
                                             # For example, script invoker may want to build docker config file before
                                             # starting the dockerd service.

        [string]$DestPath,                   # A folder to which all installs will be done. Currently there is no way
                                             # to specify the name of the leaf folder and they are hardcoded.
        [string]$OfflinePackagesPath,        # A folder for airgap/offline scenarios. If specified, will be used to save
                                             # and retrieve packages for this scenario.
        [switch]$Offline,                    # Install packages in offline/airgap mode
        [switch]$DownloadOnly,               # Download and save packages for later offline/airgap install
        [switch]$EngineOnly,                 # Skip everything except DockerEE
        [switch]$ShowVersions                # Display a list of available versions on specified [or default] channel
       )

$ErrorActionPreference="Stop"
if (-not $DryRun) {
    $global:ProgressPreference = 'SilentlyContinue'
}

# Updated manually
New-Variable -Name 'SCRIPT_SEMVER_VERSION' -Value '1.0.27' -Option Constant

# Leave the value blank except when intending to make an external release
# in which case set the value to a small phrase about the release e.g.
# 'Beta Refresh for UCP 3.3.0'
New-Variable -Name 'PUBLISH_STRING' -Value 'stable' -Option Constant

# Updated automatically by the CI pipeline
New-Variable -Name 'SCRIPT_COMMIT_SHA' -Value '6ad8439' -Option Constant

New-Variable -Name 'CRYPTOCOMPLY_PACKAGE_NAME' -Value 'CryptoComply' -Option Constant

# Internal values[constants/variables]
$script:intgenUrl=''                         # The effective Url for the package - see function genUrlFromVersionAndChannel
$script:intDownloadUrl=''
$script:intChannel=''
$script:intDockerVersion=''
$script:intContainerdVersion=''
$script:intDestPath=''
$script:intOfflinePackagesPath=''

New-Variable -Name 'DOCKER_PKG_NAME' -Value 'docker' -Option Constant
New-Variable -Name 'CONTAINERD_PKG_NAME' -Value 'containerd' -Option Constant
New-Variable -Name 'DOCKER_SVC_NAME' -Value 'docker' -Option Constant
New-Variable -Name 'CONTAINERD_SVC_NAME' -Value 'containerd' -Option Constant
New-Variable -Name 'CONTAINERS_FEATURE_NOT_INSTALLED' -Value @"
Installing the containers feature. It is a prerequisite for containers on Windows and requires a reboot.
"@ -Option Constant

New-Variable -Name 'DEFAULT_DOWNLOAD_URL' -Value "https://repos.mirantis.com" -Option Constant
New-Variable -Name 'DEFAULT_CHANNEL' -Value 'stable-25.0' -Option Constant
New-Variable -Name 'DEFAULT_DOCKER_VERSION' -Value 'latest' -Option Constant
New-Variable -Name 'DEFAULT_CONTAINERD_VERSION' -Value 'latest' -Option Constant
New-Variable -Name 'DEFAULT_CRYPTOCOMPLY_VERSION' -Value 'latest' -Option Constant

New-Variable -Name 'DEFAULT_DEST_PATH' -Value "$env:ProgramFiles" -Option Constant

New-Variable -Name 'dockerExists' -Scope 'Script' -Value $FALSE
New-Variable -Name 'containerdExists' -Scope 'Script' -Value $FALSE
New-Variable -Name 'cryptoComplyExists' -Scope 'Script' -Value $FALSE
New-Variable -Name 'mustLogoff' -Scope 'Script' -Value $FALSE

New-Variable -Name 'initDockerVer' -Scope 'Script' -Value ''
New-Variable -Name 'initContainerdVer' -Scope 'Script' -Value ''
New-Variable -Name 'finalDockerVer' -Scope 'Script' -Value ''
New-Variable -Name 'finalContainerdVer' -Scope 'Script' -Value ''

New-Variable -Name 'EXIT_REBOOT_MESSAGE' -Value "Your machine needs to be rebooted now. Installed packages will not work without reboot." -Option Constant
New-Variable -Name 'EXIT_LOGOFF_MESSAGE' -Value "The system-wide PATH has been updated. To use docker.exe and other CLI tools, please logoff and logon to update your PATH." -Option Constant

# PortNumber, Type, In/Out/Inout
# Name of the generated rule will be "docker_[PortNumber]"
$allPorts = (2376,   "tcp", "in"), `
            (2377,   "tcp", "in"), `
            (4789,   "udp", "inout"), `
            (6443,   "tcp", "inout"), `   # kube
            (7946,   "tcp", "inout"), `
            (7946,   "udp", "inout"), `
            (10250,  "tcp", "in"), `      # kubelet HTTPS port
            (12376,  "udp", "inout")

# To ensure that we can overwrite the package binaries
# successfully,  we need  to  stop  the  corresponding
# service. Sometimes  this can  impact to network  and
# cause failure  in download. To guard against  it, we
# download the packages first and saved their downloaded
# location for user later on.
$downloadedPackageLocation = @{}

function Select-First {
        [CmdletBinding(PositionalBinding = $false)]
        param(
                [Parameter()]
                [scriptblock]$Predicate = { -not [string]::IsNullOrWhiteSpace($_) },
                [Parameter()]
                $Fallback = $null,
                [Parameter(ValueFromPipeline = $true)]
                $InputObject,
                [Parameter(ValueFromRemainingArguments = $true)]
                $args
        )
        begin {
                $v = $null
                $found = $false
        }
        process {
                if ($found) { return }
                if ($InputObject -is [scriptblock]) {
                        $InputObject = &$InputObject
                }
                if (ForEach-Object -Process $Predicate -InputObject $InputObject) {
                        $v = $InputObject
                        $found = $true
                }
        }
        end {
                if (!$found) {
                        foreach ($it in $args) {
                                if ($it -is [scriptblock]) {
                                        $it = &$it
                                }
                                if (ForEach-Object -Process $Predicate -InputObject $it) {
                                        $v = $it
                                        $found = $true
                                        break
                                }
                        }
                }
                if ($found) { $v } elseif ($Fallback -is [scriptblock]) { &$Fallback } else { $Fallback }
        }
}

function updateServicesInstallStatus {
        blank
        verboseLog "Checking state of existing services"
        if (Get-Service $DOCKER_SVC_NAME -ErrorAction SilentlyContinue) {
                verboseLog "Service $DOCKER_SVC_NAME exists"
                $script:dockerExists=$TRUE
        } else {
                verboseLog "Service $DOCKER_SVC_NAME does not exist"
        }

        if ($EngineOnly) {
                return
        }

        if (Get-Service $CONTAINERD_SVC_NAME -ErrorAction SilentlyContinue) {
                verboseLog "Service $CONTAINERD_SVC_NAME exists"
                $script:containerdExists=$TRUE
        } else {
                verboseLog "Service $CONTAINERD_SVC_NAME does not exist"
        }
}

function getServicesInstallStatus {
        updateServicesInstallStatus
}

function versionAfterDeprecation {
    param($verToCheck)

    $versionRemoved = [System.Version]::new(20, 10, 15)
    # first, trim off any extra version identifiers like -tp1, -rc2, whatever.
    $verToCheck = $verToCheck.split("-")[0]
    # after 25.0, Mirantis versions of the engine use an m suffix, like
    # 25.0.7m1, or similar. This function only needs to know if the version is
    # greater than the removed version, so we can ignore the Mirantis suffix.
    # split it off, as above.
    $verToCheck = $verToCheck.split("m")[0]

    # doing both splits as above should trim the version down into something
    # that can be cast to System.Version.
   
    try {
        return ([System.Version]$verToCheck -ge $versionRemoved)
    } catch {
        return $true
    }
}

function deleteDeprecatedPlugins {
        $deprecatedPlugins = "docker-app.exe", "docker-cluster.exe", "docker-registry.exe"

        $isCurrentVerGreater = $false
        if ($script:intDockerVersion -notcontains "latest") {
            $isCurrentVerGreater = versionAfterDeprecation $script:intDockerVersion
        }

        if ($script:intDockerVersion.Contains("latest") -or $script:intDockerVersion.Contains("nightly") -or $isCurrentVerGreater) {
                Foreach ($plugin in $deprecatedPlugins) {
                        Remove-Item "$env:ProgramFiles\Docker\cli-plugins\$plugin" -Force -ErrorAction SilentlyContinue
                }
        }
}

function ensureExistingServicesStarted {
        blank
        if (-not $EngineOnly) {
                if ($script:containerdExists) {
                        if (-not $DryRun) {
                                Start-Service -Name $CONTAINERD_SVC_NAME
                        }
                        verboseLog "Started service $CONTAINERD_SVC_NAME"
                }
        }

        if ($script:dockerExists) {
                if (-not $DryRun) {
                        deleteDeprecatedPlugins
                        Start-Service -Name $DOCKER_SVC_NAME
                }
                verboseLog "Started service $DOCKER_SVC_NAME"
        }
        verboseLog "Ensured all services are started"
}

function ensureExistingServicesStopped {
        blank
        if ($script:dockerExists) {
                if (-not $DryRun) {
                        Stop-Service -Name $DOCKER_SVC_NAME -Force
                }
                verboseLog "Stopped service $DOCKER_SVC_NAME"
        }

        if ($EngineOnly) {
                verboseLog "Ensured any installed services are in a stopped state"
                return
        }

        if ($script:containerdExists) {
                if (-not $DryRun) {
                        Stop-Service -Name $CONTAINERD_SVC_NAME -Force
                }
                verboseLog "Stopped service $CONTAINERD_SVC_NAME"
        }
        verboseLog "Ensured any installed services are in a stopped state"
}

function blank {
        Write-Verbose ""
}

function verboseLog {
        Write-Verbose "$args"
}

function infoLog {
        Write-Information "$args"
}

function errorLog {
        Write-Error "$args"
}

function VerboseWithCheck {
        param($pfx, $sfx)
        if (![string]::IsNullOrWhiteSpace($sfx)) {
                verboseLog "$pfx`:$sfx"
        } else {
                verboseLog "$pfx`:[unspecified]"
        }
}

function downloadPackageToInstall {
        param($pkgname, $channel, $version)
        verboseLog "Downloading binaries for $pkgName"
        blank

        $downloadedPackageLocation["$pkgname"] = ""

        genUrlFromVersionAndChannel "$pkgname" "$channel" "$version"
        $downloadUrl = $script:genUrl

        # Trim trailing /
        $downloadUrl = $downloadUrl.TrimEnd('/')

        if ($Offline) {
                # Offline install - files already available.
                # Verify and exit if offline files missing.
                $tempZipFilePath = Join-Path -Path "$script:intOfflinePackagesPath" -ChildPath "$pkgname.zip"
                if (-not (Test-Path $tempZipFilePath -PathType leaf)) {
                        errorLog "Offline install: zip file $pkgname.zip not found at expected path $tempZipFilePath"
                        exit
                }
        } else {
                if ($DownloadOnly) {
                        $tempZipFilePath = Join-Path -Path "$script:intOfflinePackagesPath" -ChildPath "$pkgname.zip"
                        $tempDockerZapFilePath = Join-Path -Path "$script:intOfflinePackagesPath" -ChildPath "docker-ci-zap.exe"
                        if (-not (Test-Path $tempDockerZapFilePath -PathType leaf)) {
                                Invoke-WebRequest -Uri "https://github.com/moby/docker-ci-zap/raw/master/docker-ci-zap.exe" -OutFile $tempDockerZapFilePath
                        }
                } else {
                        [string] $tempname = [System.Guid]::NewGuid()
                        $tempZipFilePath = Join-Path -Path "$script:intDestPath" -ChildPath "$tempname.zip"
                }

                "Downloading $pkgname zip into $tempZipFilePath from: $downloadUrl - this may take some time"
                Invoke-WebRequest "$downloadUrl" -UseBasicParsing -OutFile "$tempZipFilePath"
                "Download of package $pkgname finished"
        }

        verboseLog "Downloaded binaries for $pkgName to $tempZipFilePath"
        $downloadedPackageLocation["$pkgname"] = "$tempZipFilePath"
}

function downloadAllPackagesForInstall {
        downloadPackageToInstall "Docker"     "$script:intChannel" "$script:intDockerVersion"

        # Check if the channel we're using includes the string "fips". If so,
        # we need to download CryptoComply installer as well
        if (needsCryptoComply($script:intDockerVersion)) {
                downloadPackageToInstall "$CRYPTOCOMPLY_PACKAGE_NAME" "$script:intChannel" "$script:intCryptoComplyVersion"
        }

        if ($EngineOnly) {
                return
        }

        downloadPackageToInstall "Containerd" "$script:intChannel" "$script:intContainerdVersion"
}

function genUrlFromVersionAndChannel {
        # All parameters below will always have a value due to defaults
        param($pkgname, $channel, $version)
        if ($channel.endswith("/fips") -and (-not $version.endswith("+fips"))) {
                $version+="+fips"
        }
        $script:genUrl = "$script:intDownloadUrl`/win`/static`/$channel`/x86_64`/$pkgname`-$version`.zip"

        # AWS is case sensitive and we use all lowers - ensure that.
        $script:genUrl = $script:genUrl.ToLower()

        verboseLog "genUrl: $pkgname $channel $version $script:genUrl"
}

function openPortWorker {
        param ($cmd)
        Invoke-Expression $cmd|Out-Null
        if ($LASTEXITCODE -ne 0) {
                Write-Warning "$cmd failed with $LASTEXITCODE. Please try to open firewall port manually"
        } else {
                verboseLog "Opened port successfully"
        }
}

# Failures opening ports are non-fatal but must be detected and logged
function openPorts {
        foreach ($curPort in $allPorts)
        {
                $curPortNumber = $curPort[0]
                $curPortProtocol = $curPort[1]
                $curPortDirection = $curPort[2]

                if (-not $DryRun) {
                        if ($curPortDirection -eq "in" -or $curPortDirection -eq "inout") {
                                verboseLog "Opening IN port $curPortNumber[$curPortDirection] for $curPortProtocol"
                                $cmd = "netsh advfirewall firewall add rule name=`"docker`_$curPortNumber`_in`" dir=in action=allow protocol=$curPortProtocol localport=$curPortNumber"
                                openPortWorker "$cmd"
                        }

                        if ($curPortDirection -eq "out" -or $curPortDirection -eq "inout") {
                                verboseLog "Opening OUT port $curPortNumber[$curPortDirection] for $curPortProtocol"
                                $cmd = "netsh advfirewall firewall add rule name=`"docker`_$curPortNumber`_out`" dir=out action=allow protocol=$curPortProtocol localport=$curPortNumber"
                                openPortWorker "$cmd"
                        }
                } else {
                        verboseLog "Opening port $curPortNumber[$curPortDirection] for $curPortProtocol"
                }
        }
}

function updatedDryRunPkgVer {
        param ($pkgname, $tempZipFilePath)

        $pkgname = $pkgname.ToLower()
        $parent = [System.IO.Path]::GetTempPath()
        [string] $name = [System.Guid]::NewGuid()
        $tempDir = Join-Path $parent $name
        New-Item -ItemType Directory -Path $tempDir|Out-Null
        Expand-Archive -Path "$tempZipFilePath" -DestinationPath "$tempDir" -Force

        # The following is intentionally fatal - we do want
        # to detect any packaging issues etc. immediately.
        if ($pkgname -eq "docker") {
                $tmp = & "$tempDir`\Docker`\docker.exe" -v|Out-String
                if ($LASTEXITCODE -ne 0) {
                        errorLog "$cmd returned $LASTEXITCODE"
                        exit
                }
                $tmp = $tmp.Trim().split('	 ',3)
                $script:finalDockerVer = $tmp[2]
        } elseif ($pkgname -eq "containerd") {
                $tmp = & "$tempDir`\Containerd`\ctr.exe" -v|Out-String
                if ($LASTEXITCODE -ne 0) {
                        errorLog "$cmd returned $LASTEXITCODE"
                        exit
                }
                $tmp = $tmp.Trim().split('	 ',3)
                $script:finalContainerdVer = $tmp[2] -replace '^v',''
        }

        Remove-Item -Recurse -Force "$tempDir"
}

function workerFunc {
        param($pkgname)

        $tempZipFilePath = $downloadedPackageLocation["$pkgname"]
        "Using preloaded zip File $tempZipFilePath for installing package $pkgname"
        if (-not $DryRun) {
                verboseLog "Expanding archive $tempZipFilePath into $script:intDestPath"
                Expand-Archive -Path "$tempZipFilePath" -DestinationPath "$script:intDestPath" -Force
        } else {
                updatedDryRunPkgVer $pkgname $tempZipFilePath
        }

        if (-not $Offline) {
                verboseLog "Removing temporary Zip File $tempZipFilePath"
                Remove-Item -Force "$tempZipFilePath"
        }
}

function ensurePathNotExist {
        param ($pathtoremove)
        $pathtoremove = $pathtoremove.ToLower().Trim().Trim('"').TrimStart('"')

        verboseLog "Ensure $pathtoremove is removed from PATH, if present"

        $newPath = ""
        $notChanged = $TRUE

        $oldpath = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).path
        ForEach ($curPathOrig in $oldpath.split(";")) {

                $curPath = $curPathOrig.ToLower().Trim().Trim('"').TrimStart('"')

                if ($curPath -ne $pathtoremove) {
                        # Add it to new path
                        $newPath += $curPathOrig + ';'
                } else {
                        # Do not add - set a flag.
                        $notChanged = $FALSE
             }
        }

        if (-not $notChanged) {
                verboseLog "Removing $pathtoremove from PATH"
                if (-not $DryRun) {
                        Set-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH -Value $newpath
                }
        } else {
                verboseLog "$pathtoremove not found in PATH"
        }
}

function checkPathExists {
        param ($oldpath, $pathToCheck)
        $oldpath = $oldpath.ToLower().Trim()
        $pathToCheck = $pathToCheck.ToLower().Trim()

        # Present at the very end without any separator
        if ($oldpath.endsWith($pathToCheck)) {
                return $TRUE
        }

        if ($oldpath.contains("$pathToCheck`;")) {
                return $TRUE
        }

        if ($oldpath.contains("$pathToCheck`"")) {
                return $TRUE
        }

        return $FALSE
}

# In case a service already existed, unregister and register it
# so that we always have a consistent state at the end.
# Verified (code and testing) that --unregister-service does not
# cause any existing windows events to be lost.
function processPackage {
        param($pkgname, $pkgSvcBinary, $pkgSvcExists)

        blank
        verboseLog "Processing package $pkgName"
        blank

        verboseLog "Installing binaries for $pkgName"
        workerFunc $pkgname
        verboseLog "$pkgname package installed"
        blank

        blank
        $svcname = $pkgname.ToLower()
        verboseLog "Installing $svcname service"
        $pkgDirPath = Join-Path "$intDestPath" -ChildPath "$pkgname"
        $pkgBinPath = Join-Path "$pkgDirPath" -ChildPath "$pkgSvcBinary"

        if ($pkgSvcExists) {
                verboseLog "Unregistering the existing $svcname service"
                if (-not $DryRun) {
                        & "$pkgBinPath" --unregister-service
                }
        }

        verboseLog "Invoking $pkgBinPath to register $svcname service"
        if (-not $DryRun) {
                & "$pkgBinPath" --register-service
                if ($LASTEXITCODE -ne 0) {
                        errorLog "Failed to register $svcname service - exit code $LASTEXITCODE"
                        exit
                }
        }

        if (-not $DryRun) {
                Set-Service docker -StartupType Automatic
        }

        verboseLog "Service $svcname registered and set to automatic"

        # Make sure the binary location is in the path
        $oldpath = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).path

        $pathExists = checkPathExists "$oldpath" "$pkgDirPath"
        if (-not $pathExists) {

                verboseLog "Adding $pkgDirPath to system PATH"

                if (-not $DryRun) {
                        $newpath = "$oldpath`;$pkgDirPath"
                        Set-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH -Value $newpath
                }
        } else {
                verboseLog "Skipping PATH modification: $pkgDirPath already exists in system PATH"
        }

        # Modify the current PATH also - so that calls to ctr and docker.exe work
        # OK to do so for dryrun as well since this only impacts the current process.
        $pathExists = checkPathExists "$Env:Path" "$pkgDirPath"
        if (-not $pathExists) {
                $Env:Path += "`;$pkgDirPath"
        }

        blank
}

# In case a service already existed, unregister and register it
# so that we always have a consistent state at the end.
# Verified (code and testing) that --unregister-service does not
# cause any existing windows events to be lost.
function uninstallPackage {
        param($pkgname, $pkgSvcBinary, $pkgSvcExists)

        blank
        verboseLog "Uninstalling package $pkgName"
        blank

        blank
        $svcname = $pkgname.ToLower()
        verboseLog "Uninstalling $svcname service"

        $pkgDirPath = Join-Path "$intDestPath" -ChildPath "$pkgname"
        $pkgBinPath = Join-Path "$pkgDirPath" -ChildPath "$pkgSvcBinary"

        if ($pkgSvcExists) {
                verboseLog "Unregistering the existing $svcname service"
                if (-not $DryRun) {
                        & "$pkgBinPath" --unregister-service
                }
        }

        # We need to "zap" the docker folder instead of deleting it.

        if($Offline) {
                # For offline, we expect/recommend docker-ci-zap to be present in $script:intOfflinePackagesPath
                $tempDockerZapFilePath = Join-Path -Path "$script:intOfflinePackagesPath" -ChildPath "docker-ci-zap.exe"
                if (-not (Test-Path $tempDockerZapFilePath -PathType leaf)) {
                        errorLog "Docker Zap util is unavailable at $tempDockerZapFilePath"
                        exit
                }
                & $tempDockerZapFilePath -folder $pkgDirPath
        }
        else {
                Invoke-WebRequest -Uri "https://github.com/moby/docker-ci-zap/raw/master/docker-ci-zap.exe" -OutFile "$env:TEMP\docker-ci-zap.exe"
                & $env:TEMP\docker-ci-zap.exe -folder $pkgDirPath

                # Remove the util
                Remove-Item  $env:TEMP\docker-ci-zap.exe
        }

        # Make sure the binary location is removed from the path
        ensurePathNotExist "$pkgDirPath"
}

function systemFIPSMode {
        if ($null -ne $script:mockSystemFIPSMode) {
                return $script:mockSystemFIPSMode
        }
        [System.Security.Cryptography.Cryptoconfig]::AllowOnlyFipsAlgorithms
}

function reconcileParams {

        verboseLog "Reconciling parameters for the script"

        # Binaries CDN location - a default value must be specified
        $script:intDownloadUrl = "$(
                Select-First $downloadUrl $env:DOWNLOAD_URL -Fallback $DEFAULT_DOWNLOAD_URL
        )".Trim()
        verboseLog "Using Docker Url: $script:intDownloadUrl"

        # Channel name (e.g. test, stable etc.)
        $script:intChannel = "$(
                Select-First $Channel $env:CHANNEL {
                        if ("$(Select-First $DockerVersion $env:DOCKER_VERSION)".Trim() -match '^(\d+)' -and [int]$Matches.1 -lt 25) {
                                "stable" # Legacy default channel for MCR 23.0 and earlier
                        }
                } {
                        if ($(systemFIPSMode)) { "${DEFAULT_CHANNEL}/fips" }
                } -Fallback $DEFAULT_CHANNEL
        )".Trim()
        VerboseWithCheck "Using Channel" "$script:intChannel"

        # Docker and containerd binaries version
        # For offline, we shouldn't care about latest.
        $script:intDockerVersion = "$(
                Select-First $DockerVersion $env:DOCKER_VERSION {
                        if (-not $Offline) { getNumericallyHigherVersion $(getPackageIndex).x86_64.docker }
                } -Fallback $DEFAULT_DOCKER_VERSION
        )".Trim()
        VerboseWithCheck "Using Docker Version" "$script:intDockerVersion"

        $script:intContainerdVersion = "$(
                Select-First $ContainerdVersion $env:CONTAINERD_VERSION {
                        if (-not $Offline) { getNumericallyHigherVersion $(getPackageIndex).x86_64.containerd }
                } -Fallback $DEFAULT_CONTAINERD_VERSION
        )".Trim()
        VerboseWithCheck "Using Containerd Version" "$script:intContainerdVersion"

        $script:intCryptoComplyVersion = "$(
                Select-First $CryptoComplyVersion $env:CRYPTOCOMPLY_VERSION {
                        if (-not $Offline) { getNumericallyHigherVersion $(getPackageIndex).x86_64.cryptocomply }
                } -Fallback $DEFAULT_CRYPTOCOMPLY_VERSION
        )".Trim()
        VerboseWithCheck "Using Cryptocomply Version" "$script:intCryptoComplyVersion"

        # Destination path for installing the binaries
        $script:intDestPath = "$(
                Select-First $DestPath -Fallback $DEFAULT_DEST_PATH
        )".Trim()
        verboseLog "Using Destination Path: $script:intDestPath"

        $defLocation = Get-Location
        # Path for saving/loading for airgap installs
        $script:intOfflinePackagesPath = "$(
                Select-First $OfflinePackagesPath -Fallback $defLocation
        )".Trim()
        verboseLog "Using Offline Packages Path: $script:intOfflinePackagesPath"
}

function cmpLists($a, $b) {
    $len = [Math]::Min($a.Length, $b.Length)
    for ($i = 0; $i -lt $len; $i++) {
        if ($a[$i] -is $b[$i].GetType()) {
            $cmp = $a[$i].CompareTo($b[$i])
            if ($cmp -ne 0) {
                return $cmp
            }
        } else {
           # Strings sort before numbers (1.0.a < 1.0.0)
           if ($a[$i] -is [string]) {
               return -1
           } else {
               return 1
           }
        }
    }
    # Longer lists sort after shorter ones
    # (as if the shorter list was padded with $nulls)
    return $a.Length.CompareTo($b.Length)
}

class PackageVersion : IComparable, System.IEquatable[Object]
{
    [string]$Name
    [string]$FullVersion
    [object[]]$Main
    [object[]]$Pre
    [string]$Build

    [int] CompareTo([Object]$other) {
        if ($null -eq $other) {
            return 1
        }

        if ($other -isnot $this.GetType()) {
                $errorMessage = $script:localizedData.InvalidTypeForCompare -f @(
                $this.GetType().FullName,
                $other.GetType().FullName
            )

            New-InvalidArgumentException -ArgumentName 'Object' -Message $errorMessage
        }

        $cmp = cmpLists $this.Main $other.Main
        if ($cmp -ne 0) {
            return $cmp
        }

        # Prerelease versions sort before released versions
        if ($this.Pre.Length -eq 0 -and $other.Pre.Length -ne 0) {
            return 1
        } elseif ($this.Pre.Length -ne 0 -and $other.Pre.Length -eq 0) {
            return -1
        }
        if ($this.Pre[0] -is [string] -and $other.Pre[0] -is [string]) {
            # Special case for prerelease strings:
            # (anything else) < dev < nightly < beta < tp < rc
            $order = @('dev', 'nightly', 'beta', 'tp', 'rc')
            $thispre0, $thisrest = $this.Pre
            $otherpre0, $otherrest = $other.Pre
            $thisIndex = $order.IndexOf(($thispre0 -replace '\.$',''))
            $otherIndex = $order.IndexOf(($otherpre0 -replace '\.$',''))
            if ($thisIndex -lt $otherIndex) {
                return -1
            } elseif ($thisIndex -gt $otherIndex) {
                return 1
            } elseif ($thisIndex -lt 0 -and $otherIndex -lt 0) {
                # Neither string is a special case - compare normally
                $cmp = $thispre0.CompareTo($otherpre0)
                if ($cmp -ne 0) {
                    return $cmp
                }
            }
            $cmp = cmpLists $thisrest $otherrest
        } else {
            $cmp = cmpLists $this.Pre $other.Pre
        }
        if ($cmp -ne 0) {
            return $cmp
        }
        return $this.Build.CompareTo($other.Build)
    }

    [bool] Equals([Object]$other) {
        if ($other -isnot $this.GetType()) {
            return $false
        }

        return $this.Name -eq $other.Name -and
               $this.FullVersion -eq $other.FullVersion -and
               (cmpLists $this.Main $other.Main) -eq 0 -and
               (cmpLists $this.Pre $other.Pre) -eq 0 -and
               $this.Build -eq $other.Build
    }
}

<#
  .DESCRIPTION
    explodeVersionFields splits a string on runs of digits and non-digits,
    returning an array of alternating integers and strings.

  .EXAMPLE
    explodeVersionFields "25.0.7m1"
    # Returns: 25, ".", 0, ".", 7, "m", 1

    explodeVersionFields "a.b.c12.3"
    # Returns: "a.b.c", 12, ".", 3

    explodeVersionFields "rc.1"
    # Returns: "rc.", 1
#>
function explodeVersionFields {
    param($s)

    $out = @()
    $accumulator = ''
    $state = ''
    foreach ($c in [char[]]$s) {
        $isdigit = [char]::IsDigit($c)
        if ($state -eq '') {
            $state = if ($isdigit) {'num'} else {'alpha'}
        }

        if (($isdigit -and $state -eq 'num') -or (-not $isdigit -and $state -eq 'alpha')) {
            $accumulator += $c
        } else {
            if ($accumulator -ne '') {
                if ($state -eq 'num') {
                    $out += [int]$accumulator
                } else {
                    $out += $accumulator
                }
            }
            $accumulator = [string]$c
            $state = if ($isdigit) {'num'} else {'alpha'}
        }
    }
    if ($accumulator -ne '') {
        if ($state -eq 'num') {
            $out += [int]$accumulator
        } else {
            $out += $accumulator
        }
    }

    return ,$out
}

function parsePackageVersions {
    # The names of these packages are like follows:
    #
    #   * 1.7.20
    #   * 1.7.22-rc.1
    #   * 25.0.6-tp2
    #   * 25.0.7m1-tp1
    #
    # This means file names are composed of a few parts:
    # 
    #    25 . 0 . 7  m1  -  tp     1  +fips
    #   â””â”¬â”€â”˜ â””â”¬â”˜ â””â”¬â”˜â””â”¬â”€â”˜â””â”¬â”˜â””â”€â”¬â”˜â””â”¬â”˜â””â”¬â”˜â””â”€â”€â”¬â”€â”€â”˜
    #    â”‚    â”‚   â”‚  â”‚   â”‚   â”‚  â”‚  â”‚    â”” fips designator, if this is a fips package (optional)
    #    â”‚    â”‚   â”‚  â”‚   â”‚   â”‚  â”‚  â”” prerelease version (optional)
    #    â”‚    â”‚   â”‚  â”‚   â”‚   â”‚  â”” might be a dot here
    #    â”‚    â”‚   â”‚  â”‚   â”‚   â”” prerelease designator (optional)
    #    â”‚    â”‚   â”‚  â”‚   â”” prerelease separator (optional)
    #    â”‚    â”‚   â”‚  â”” Mirantis release version (not present prior to 25.0)
    #    â”‚    â”‚   â”” patch version
    #    â”‚    â”” "minor" version (but not really, because we're not semver)
    #    â”” "major" version (but as above)
    # We need to separate out and classify all the versiony bits.

    param($packages)

    $packageRegex = '^\s*(?<fullVersion>(?<main>\d+\.[^-+]+)(-(?<pre>[^+]+))?(\+(?<build>.+))?)$'

    return $packages | Select-String -CaseSensitive -Pattern $packageRegex  | ForEach-Object {
        [PackageVersion]@{
            Name = $_.Matches.Value
            # fullVersion is the version of the package without the package
            # name at the beginning or .zip at the end. It is what is
            # ultimately passed into the download-y bits.
            FullVersion = $_.Matches[0].Groups['fullVersion'].Value
            Main = explodeVersionFields($_.Matches[0].Groups['main'].Value)
            Pre = explodeVersionFields($_.Matches[0].Groups['pre'].Value)
            Build = $_.Matches[0].Groups['build'].Value
        }
    } | Sort-Object
}


function getNumericallyHigherVersion {
    param($packages)

    return parsePackageVersions $packages | 
        Select-Object -Last 1 -ExpandProperty FullVersion
}

# needsCryptoComply returns true
#   * if the package major.minor.patch is greater
#     than 25.0.13, and the package is +fips. Using only the major.minor.patch
#     should include tps, rcs, patches, etc. FIPS versions 25.0.13 and greater
#     require the CryptoComply package be installed.
#   * if we're in offline mode and the offline packages directory includes
#     CryptoComply.zip
function needsCryptoComply {
    param($dockerVer)

    $pkgVer = (parsePackageVersions $dockerVer | Select-Object -Last 1)
  
    if ($Offline) {
        return Test-Path (Join-Path -Path $script:OfflinePackagesPath -ChildPath "CryptoComply.zip") -PathType Leaf
    }
    return ($script:intChannel -match "fips") -and (cmpLists $pkgVer.Main @(25, '.', 0, '.', 13)) -ge 0
}

$packageIndexCache = @{}
function getPackageIndex {
   param([string]$Channel = $script:intChannel)
   $indexUrl = "$script:intDownloadUrl`/win`/static`/$Channel`/index.json"
   if (-not $packageIndexCache.ContainsKey($indexUrl)) {
       $packageIndexCache[$indexUrl] = (Invoke-WebRequest -UseBasicParsing -Uri $indexUrl).Content | ConvertFrom-Json
   }
   return $packageIndexCache[$indexUrl]
}

# Because we only ever use the versions for informational messages,
# we treat errors here as non-fatal.
function getDockerVer {
        if (Get-Command "docker.exe" -ErrorAction SilentlyContinue)
        {
                $tmp = docker -v|Out-String
                if ($LASTEXITCODE -eq 0) {
                        $tmp = $tmp.Trim().split('	 ',3)
                        return $tmp[2]
                } else {
                        verboseLog "docker -v returned $LASTEXITCODE"
                }
        } else {
                verboseLog "docker not in PATH"
        }

        return ''
}

function getContainerdVer {
        if (Get-Command "ctr.exe" -ErrorAction SilentlyContinue)
        {
                $tmp = ctr -v|Out-String
                if ($LASTEXITCODE -eq 0) {
                $tmp = $tmp.Trim().split('	 ',3)
                        return $tmp[2] -replace '^v',''
                } else {
                        verboseLog "ctr version returned $LASTEXITCODE"
                }
        } else {
                verboseLog "ctr not in PATH"
        }

        return ''
}

function initState {
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        reconcileParams

        getServicesInstallStatus

        if ($script:dockerExists) {
                $script:initDockerVer = getDockerVer
        }

        if ($EngineOnly) {
                return
        }

        if ($script:containerdExists) {
                $script:initContainerdVer = getContainerdVer
        }
}

function processAllPackagesForInstall {
        # if we're using a fips version of dockerd, install the cryptocomply
        # package. This does not use processPackage, as processPackage unzips
        # to a directory and then installs a service. We just need to unzip the
        # msi file and run it. We'll unzip it in the path that we're storing
        # our zip files.
        if (needsCryptoComply($script:intDockerVersion)) {
                verboseLog "Docker version $script:intDockerVersion requires CryptoComply"
                $tempZipFilePath = Get-Item $downloadedPackageLocation["$CRYPTOCOMPLY_PACKAGE_NAME"]
                "Using preloaded zip File $tempZipFilePath for installing $CRYPTOCOMPLY_PACKAGE_NAME"
                $zipPath = Join-Path -Path $tempZipFilePath.DirectoryName -ChildPath $tempZipFilePath.BaseName
                if (-not $DryRun) {
                      # TODO(dperny): We're cleaning everything up after, but
                      # we should still probably use the designated temporary
                      # files folder for this setup stuff. We'll follow our
                      # existing pattern, for now, though, and just unpack to
                      # a folder in the same directory.
                      verboseLog "Expanding archive $tempZipFilePath into $zipPath"
                      Expand-Archive -Path $tempZipFilePath -DestinationPath $zipPath

                      # Now, we run the installer. Get the .msi file from the
                      # list of files (in case we throw in a license file or
                      # something later) and execute it.
                      foreach ($file in (Get-ChildItem -Path "$zipPath/*.msi")) {
                            Install-Package -ProviderName msi $file
                      }
                } else {
                      updatedDryRunPkgVer $CRYPTOCOMPLY_PACKAGE_NAME $tempZipFilePath
                }
                if (-not $Offline) {
                      verboseLog "Removing temporary Zip File $tempZipFilePath"
                      Remove-Item -Force $tempZipFilePath
                }
                verboseLog "Removing temporary CryptoComply installer"
                # I don't want to do -Recurse on a path variable because
                # one screw-up and we erase Windows and that would be Bad
                foreach ($file in (Get-ChildItem -Path $zipPath)) {
                      verboseLog "Removing $($file.FullName)"
                      Remove-Item -Force $file.FullName
                }
                verboseLog "Removing $zipPath"
                Remove-Item -Force $zipPath
        }

        processPackage "Docker"     "dockerd.exe"    $script:dockerExists
        $script:dockerExists = $TRUE

        if ($EngineOnly) {
                return
        }

        processPackage "Containerd" "containerd.exe" $script:containerdExists
        $script:containerdExists = $TRUE
}

function processAllPackagesForUninstall {
        if ($script:dockerExists) {
                uninstallPackage "Docker"     "dockerd.exe"  $script:dockerExists
                if (![string]::IsNullOrWhiteSpace($script:initDockerVer)) {
                        "Uninstalled package Docker $script:initDockerVer"
                } else {
                        "Uninstalled package Docker"
                }
                $script:dockerExists = $FALSE
        } else {
                "Uninstall - package Docker does not exist"
        }

        if ($EngineOnly) {
                return
        }

        if ($script:containerdExists) {
                uninstallPackage "Containerd" "containerd.exe" $script:containerdExists
                if (![string]::IsNullOrWhiteSpace($script:initContainerdVer)) {
                        "Uninstalled package Containerd $script:initContainerdVer"
                } else {
                        "Uninstalled package Containerd"
                }
                $script:containerdExists = $FALSE
        } else {
                "Uninstall - package Containerd does not exist"
        }
}

function printScriptVer {
        "install.ps1 version 1.0.27 build 6ad8439c9a367155520e6d364e6d09fe13a4f89a"
        if (![string]::IsNullOrWhiteSpace($PUBLISH_STRING)) {
                "For $PUBLISH_STRING"
        }
}

function printPackageVersions {
        reconcileParams

        $json = getPackageIndex
        forEach ($curPkg in ("docker", "containerd")) {
                $omitlatest=@($json.x86_64.$curPkg) -notmatch 'latest'
                [array]::Reverse($omitlatest)
                Write-Host "$curPkg`:" ($omitlatest -join ", ")
        }
}

function installOrUninstall {
        if ($Ver) {
                printScriptVer
                exit
        }

        if ($ShowVersions) {
                printPackageVersions
                exit
        }

        $rebootReminder = $FALSE

        if (-not $DryRun -and -not $DownloadOnly) {

            if (-not ([bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544"))) {
                    # Possible TODO: Addressing the need to have a non-admin access docker client
                    # This requires:
                    # 1.  Specifying a security group whose users can access docker client even if they are not admins
                    # 2.  Creation of this security group and adding a user to it
                    # Both of the above need admits so we cannot do that automatically at this stage.
                    # We could possibly provide guidance to what an adinistrator user of this script needs to do.
                    errorLog "Installation of Docker EE requires administrator rights on Windows"
                    "By adding the group option to the Docker Daemon config file, it is possible to execute Docker commands as non-admin."
                    "Specifying the Security group for allowing non-admins access to Docker:https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-docker/configure-docker-daemon#set-docker-security-group"
                    "To create SG and add user to it, execute as an admin: net localgroup <Group Name> /add && net localgroup <Group Name> <User Name> /add"
                    exit
            }
        }

        if (-not $DownloadOnly) {
            # The script should work as long as its prerequisites
            # [Containers feature] is installed.

            # Make sure containers feature is enabled on the host
            if (-not $Uninstall) {
                    if ((get-windowsoptionalfeature -Online -FeatureName containers).State -ne 'Enabled') {
                            blank
                            blank
                            if (-not $DryRun) {
                                    "$CONTAINERS_FEATURE_NOT_INSTALLED"
                                    Invoke-Expression "Enable-WindowsOptionalFeature -Online -FeatureName containers -NoRestart -WarningAction SilentlyContinue -All"|Out-Null
                                    $rebootReminder = $TRUE
                            } else {
                                    "Containers feature is not installed and is required for Docker EE"
                                    "Dry run is ON - proceeding as if the feature was installed without actually installing it"
                            }
                            blank
                            blank
                    } else {
                        verboseLog "Verified that the feature Containers is installed"
                    }
            }
        }

        blank
        initState

        # Stopping services can impact network connectivity.
        # This is pronounced when dockerd is stopped and we
        # have reports of downloads failing as a result. So
        # we download before stopping the service(s).
        if (-not $Uninstall) {
                downloadAllPackagesForInstall

                if ($DownloadOnly) {
                        exit
                }

                if (-not $DryRun -and -not $EngineOnly) {
                        md -Force c:\k\cni\config | Out-Null
                }
        }

        # Stop existing services so that we could overwrite the binaries
        ensureExistingServicesStopped

        if ($Uninstall) {
                # Uninstall services
                processAllPackagesForUninstall
        } else {
                # Install services
                processAllPackagesForInstall

                # For DryRun, the version numbers have already been updated
                if (-not $DryRun) {
                        $script:finalDockerVer = getDockerVer
                        $script:finalContainerdVer = getContainerdVer
                }

                if (-not $EngineOnly) {
                        openPorts
                }

                # Unless we are asked to leave the services in a stopped state, we need to start them.
                if (-not $rebootReminder -and -not $NoServiceStarts) {
                        ensureExistingServicesStarted
                }

                blank
                # Before exiting, emit a message about different packages installed/upgraded
                # and their versions number(s) [pre-install and post-install].
                if ($script:finalDockerVer -ne '') {
                        if ($script:initDockerVer -ne '' -and $script:initDockerVer -ne $script:finalDockerVer) {
                                "Updated Docker from $script:initDockerVer to $script:finalDockerVer"
                        } else {
                                "Installed Docker $script:finalDockerVer"
                        }
                }

                if (-not $EngineOnly) {
                        if ($script:finalContainerdVer -ne '') {
                                if ($script:initContainerdVer -ne '' -and $script:initContainerdVer -ne $script:finalContainerdVer) {
                                        "Updated Containerd from $script:initContainerdVer to $script:finalContainerdVer"
                                } else {
                                        "Installed Containerd $script:finalContainerdVer"
                                }
                        }
                }

                blank
                "Install/upgrade completed"

                # Reboot > Logoff. So show only reboot message even if logoff is also set.
                if ($rebootReminder) {
                        Write-Warning $EXIT_REBOOT_MESSAGE
                } elseif ($script:mustLogoff) {
                        Write-Warning $EXIT_LOGOFF_MESSAGE
                }
        }
}

if ($MyInvocation.InvocationName -ne '.') {
  installOrUninstall
}

# SIG # Begin signature block
# MIInSwYJKoZIhvcNAQcCoIInPDCCJzgCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCcnRxShLb2MDxU
# ria8KfCqJkyUgRYvvi1LasKJYmb1iaCCINEwggWNMIIEdaADAgECAhAOmxiO+dAt
# 5+/bUOIIQBhaMA0GCSqGSIb3DQEBDAUAMGUxCzAJBgNVBAYTAlVTMRUwEwYDVQQK
# EwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xJDAiBgNV
# BAMTG0RpZ2lDZXJ0IEFzc3VyZWQgSUQgUm9vdCBDQTAeFw0yMjA4MDEwMDAwMDBa
# Fw0zMTExMDkyMzU5NTlaMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2Vy
# dCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lD
# ZXJ0IFRydXN0ZWQgUm9vdCBHNDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC
# ggIBAL/mkHNo3rvkXUo8MCIwaTPswqclLskhPfKK2FnC4SmnPVirdprNrnsbhA3E
# MB/zG6Q4FutWxpdtHauyefLKEdLkX9YFPFIPUh/GnhWlfr6fqVcWWVVyr2iTcMKy
# unWZanMylNEQRBAu34LzB4TmdDttceItDBvuINXJIB1jKS3O7F5OyJP4IWGbNOsF
# xl7sWxq868nPzaw0QF+xembud8hIqGZXV59UWI4MK7dPpzDZVu7Ke13jrclPXuU1
# 5zHL2pNe3I6PgNq2kZhAkHnDeMe2scS1ahg4AxCN2NQ3pC4FfYj1gj4QkXCrVYJB
# MtfbBHMqbpEBfCFM1LyuGwN1XXhm2ToxRJozQL8I11pJpMLmqaBn3aQnvKFPObUR
# WBf3JFxGj2T3wWmIdph2PVldQnaHiZdpekjw4KISG2aadMreSx7nDmOu5tTvkpI6
# nj3cAORFJYm2mkQZK37AlLTSYW3rM9nF30sEAMx9HJXDj/chsrIRt7t/8tWMcCxB
# YKqxYxhElRp2Yn72gLD76GSmM9GJB+G9t+ZDpBi4pncB4Q+UDCEdslQpJYls5Q5S
# UUd0viastkF13nqsX40/ybzTQRESW+UQUOsxxcpyFiIJ33xMdT9j7CFfxCBRa2+x
# q4aLT8LWRV+dIPyhHsXAj6KxfgommfXkaS+YHS312amyHeUbAgMBAAGjggE6MIIB
# NjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTs1+OC0nFdZEzfLmc/57qYrhwP
# TzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzAOBgNVHQ8BAf8EBAMC
# AYYweQYIKwYBBQUHAQEEbTBrMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdp
# Y2VydC5jb20wQwYIKwYBBQUHMAKGN2h0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNv
# bS9EaWdpQ2VydEFzc3VyZWRJRFJvb3RDQS5jcnQwRQYDVR0fBD4wPDA6oDigNoY0
# aHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENB
# LmNybDARBgNVHSAECjAIMAYGBFUdIAAwDQYJKoZIhvcNAQEMBQADggEBAHCgv0Nc
# Vec4X6CjdBs9thbX979XB72arKGHLOyFXqkauyL4hxppVCLtpIh3bb0aFPQTSnov
# Lbc47/T/gLn4offyct4kvFIDyE7QKt76LVbP+fT3rDB6mouyXtTP0UNEm0Mh65Zy
# oUi0mcudT6cGAxN3J0TU53/oWajwvy8LpunyNDzs9wPHh6jSTEAZNUZqaVSwuKFW
# juyk1T3osdz9HNj0d1pcVIxv76FQPfx2CWiEn2/K2yCNNWAcAgPLILCsWKAOQGPF
# mCLBsln1VWvPJ6tsds5vIy30fnFqI2si/xK4VC0nftg62fC2h5b9W9FcrBjDTZ9z
# twGpn1eqXijiuZQwggawMIIEmKADAgECAhAIrUCyYNKcTJ9ezam9k67ZMA0GCSqG
# SIb3DQEBDAUAMGIxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx
# GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lDZXJ0IFRy
# dXN0ZWQgUm9vdCBHNDAeFw0yMTA0MjkwMDAwMDBaFw0zNjA0MjgyMzU5NTlaMGkx
# CzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4
# RGlnaUNlcnQgVHJ1c3RlZCBHNCBDb2RlIFNpZ25pbmcgUlNBNDA5NiBTSEEzODQg
# MjAyMSBDQTEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDVtC9C0Cit
# eLdd1TlZG7GIQvUzjOs9gZdwxbvEhSYwn6SOaNhc9es0JAfhS0/TeEP0F9ce2vnS
# 1WcaUk8OoVf8iJnBkcyBAz5NcCRks43iCH00fUyAVxJrQ5qZ8sU7H/Lvy0daE6ZM
# swEgJfMQ04uy+wjwiuCdCcBlp/qYgEk1hz1RGeiQIXhFLqGfLOEYwhrMxe6TSXBC
# Mo/7xuoc82VokaJNTIIRSFJo3hC9FFdd6BgTZcV/sk+FLEikVoQ11vkunKoAFdE3
# /hoGlMJ8yOobMubKwvSnowMOdKWvObarYBLj6Na59zHh3K3kGKDYwSNHR7OhD26j
# q22YBoMbt2pnLdK9RBqSEIGPsDsJ18ebMlrC/2pgVItJwZPt4bRc4G/rJvmM1bL5
# OBDm6s6R9b7T+2+TYTRcvJNFKIM2KmYoX7BzzosmJQayg9Rc9hUZTO1i4F4z8ujo
# 7AqnsAMrkbI2eb73rQgedaZlzLvjSFDzd5Ea/ttQokbIYViY9XwCFjyDKK05huzU
# tw1T0PhH5nUwjewwk3YUpltLXXRhTT8SkXbev1jLchApQfDVxW0mdmgRQRNYmtwm
# KwH0iU1Z23jPgUo+QEdfyYFQc4UQIyFZYIpkVMHMIRroOBl8ZhzNeDhFMJlP/2NP
# TLuqDQhTQXxYPUez+rbsjDIJAsxsPAxWEQIDAQABo4IBWTCCAVUwEgYDVR0TAQH/
# BAgwBgEB/wIBADAdBgNVHQ4EFgQUaDfg67Y7+F8Rhvv+YXsIiGX0TkIwHwYDVR0j
# BBgwFoAU7NfjgtJxXWRM3y5nP+e6mK4cD08wDgYDVR0PAQH/BAQDAgGGMBMGA1Ud
# JQQMMAoGCCsGAQUFBwMDMHcGCCsGAQUFBwEBBGswaTAkBggrBgEFBQcwAYYYaHR0
# cDovL29jc3AuZGlnaWNlcnQuY29tMEEGCCsGAQUFBzAChjVodHRwOi8vY2FjZXJ0
# cy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNydDBDBgNVHR8E
# PDA6MDigNqA0hjJodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVz
# dGVkUm9vdEc0LmNybDAcBgNVHSAEFTATMAcGBWeBDAEDMAgGBmeBDAEEATANBgkq
# hkiG9w0BAQwFAAOCAgEAOiNEPY0Idu6PvDqZ01bgAhql+Eg08yy25nRm95RysQDK
# r2wwJxMSnpBEn0v9nqN8JtU3vDpdSG2V1T9J9Ce7FoFFUP2cvbaF4HZ+N3HLIvda
# qpDP9ZNq4+sg0dVQeYiaiorBtr2hSBh+3NiAGhEZGM1hmYFW9snjdufE5BtfQ/g+
# lP92OT2e1JnPSt0o618moZVYSNUa/tcnP/2Q0XaG3RywYFzzDaju4ImhvTnhOE7a
# brs2nfvlIVNaw8rpavGiPttDuDPITzgUkpn13c5UbdldAhQfQDN8A+KVssIhdXNS
# y0bYxDQcoqVLjc1vdjcshT8azibpGL6QB7BDf5WIIIJw8MzK7/0pNVwfiThV9zeK
# iwmhywvpMRr/LhlcOXHhvpynCgbWJme3kuZOX956rEnPLqR0kq3bPKSchh/jwVYb
# KyP/j7XqiHtwa+aguv06P0WmxOgWkVKLQcBIhEuWTatEQOON8BUozu3xGFYHKi8Q
# xAwIZDwzj64ojDzLj4gLDb879M4ee47vtevLt/B3E+bnKD+sEq6lLyJsQfmCXBVm
# zGwOysWGw/YmMwwHS6DTBwJqakAwSEs0qFEgu60bhQjiWQ1tygVQK+pKHJ6l/aCn
# HwZ05/LWUpD9r4VIIflXO7ScA+2GRfS0YW6/aOImYIbqyK+p/pQd52MbOoZWeE4w
# gga0MIIEnKADAgECAhANx6xXBf8hmS5AQyIMOkmGMA0GCSqGSIb3DQEBCwUAMGIx
# CzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3
# dy5kaWdpY2VydC5jb20xITAfBgNVBAMTGERpZ2lDZXJ0IFRydXN0ZWQgUm9vdCBH
# NDAeFw0yNTA1MDcwMDAwMDBaFw0zODAxMTQyMzU5NTlaMGkxCzAJBgNVBAYTAlVT
# MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1
# c3RlZCBHNCBUaW1lU3RhbXBpbmcgUlNBNDA5NiBTSEEyNTYgMjAyNSBDQTEwggIi
# MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC0eDHTCphBcr48RsAcrHXbo0Zo
# dLRRF51NrY0NlLWZloMsVO1DahGPNRcybEKq+RuwOnPhof6pvF4uGjwjqNjfEvUi
# 6wuim5bap+0lgloM2zX4kftn5B1IpYzTqpyFQ/4Bt0mAxAHeHYNnQxqXmRinvuNg
# xVBdJkf77S2uPoCj7GH8BLuxBG5AvftBdsOECS1UkxBvMgEdgkFiDNYiOTx4OtiF
# cMSkqTtF2hfQz3zQSku2Ws3IfDReb6e3mmdglTcaarps0wjUjsZvkgFkriK9tUKJ
# m/s80FiocSk1VYLZlDwFt+cVFBURJg6zMUjZa/zbCclF83bRVFLeGkuAhHiGPMvS
# GmhgaTzVyhYn4p0+8y9oHRaQT/aofEnS5xLrfxnGpTXiUOeSLsJygoLPp66bkDX1
# ZlAeSpQl92QOMeRxykvq6gbylsXQskBBBnGy3tW/AMOMCZIVNSaz7BX8VtYGqLt9
# MmeOreGPRdtBx3yGOP+rx3rKWDEJlIqLXvJWnY0v5ydPpOjL6s36czwzsucuoKs7
# Yk/ehb//Wx+5kMqIMRvUBDx6z1ev+7psNOdgJMoiwOrUG2ZdSoQbU2rMkpLiQ6bG
# RinZbI4OLu9BMIFm1UUl9VnePs6BaaeEWvjJSjNm2qA+sdFUeEY0qVjPKOWug/G6
# X5uAiynM7Bu2ayBjUwIDAQABo4IBXTCCAVkwEgYDVR0TAQH/BAgwBgEB/wIBADAd
# BgNVHQ4EFgQU729TSunkBnx6yuKQVvYv1Ensy04wHwYDVR0jBBgwFoAU7NfjgtJx
# XWRM3y5nP+e6mK4cD08wDgYDVR0PAQH/BAQDAgGGMBMGA1UdJQQMMAoGCCsGAQUF
# BwMIMHcGCCsGAQUFBwEBBGswaTAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGln
# aWNlcnQuY29tMEEGCCsGAQUFBzAChjVodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5j
# b20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNydDBDBgNVHR8EPDA6MDigNqA0hjJo
# dHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRUcnVzdGVkUm9vdEc0LmNy
# bDAgBgNVHSAEGTAXMAgGBmeBDAEEAjALBglghkgBhv1sBwEwDQYJKoZIhvcNAQEL
# BQADggIBABfO+xaAHP4HPRF2cTC9vgvItTSmf83Qh8WIGjB/T8ObXAZz8OjuhUxj
# aaFdleMM0lBryPTQM2qEJPe36zwbSI/mS83afsl3YTj+IQhQE7jU/kXjjytJgnn0
# hvrV6hqWGd3rLAUt6vJy9lMDPjTLxLgXf9r5nWMQwr8Myb9rEVKChHyfpzee5kH0
# F8HABBgr0UdqirZ7bowe9Vj2AIMD8liyrukZ2iA/wdG2th9y1IsA0QF8dTXqvcnT
# mpfeQh35k5zOCPmSNq1UH410ANVko43+Cdmu4y81hjajV/gxdEkMx1NKU4uHQcKf
# ZxAvBAKqMVuqte69M9J6A47OvgRaPs+2ykgcGV00TYr2Lr3ty9qIijanrUR3anzE
# wlvzZiiyfTPjLbnFRsjsYg39OlV8cipDoq7+qNNjqFzeGxcytL5TTLL4ZaoBdqbh
# OhZ3ZRDUphPvSRmMThi0vw9vODRzW6AxnJll38F0cuJG7uEBYTptMSbhdhGQDpOX
# gpIUsWTjd6xpR6oaQf/DJbg3s6KCLPAlZ66RzIg9sC+NJpud/v4+7RWsWCiKi9EO
# LLHfMR2ZyJ/+xhCx9yHbxtl5TPau1j/1MIDpMPx0LckTetiSuEtQvLsNz3Qbp7wG
# WqbIiOWCnb5WqxL3/BAPvIXKUjPSxyZsq8WhbaM2tszWkPZPubdcMIIG3zCCBMeg
# AwIBAgIQD5jz1vjMKxeT5tmM8JXcyTANBgkqhkiG9w0BAQsFADBpMQswCQYDVQQG
# EwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xQTA/BgNVBAMTOERpZ2lDZXJ0
# IFRydXN0ZWQgRzQgQ29kZSBTaWduaW5nIFJTQTQwOTYgU0hBMzg0IDIwMjEgQ0Ex
# MB4XDTI1MDcwMTAwMDAwMFoXDTI2MDcwNzIzNTk1OVowZzELMAkGA1UEBhMCVVMx
# EzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcTCENhbXBiZWxsMRcwFQYDVQQK
# Ew5NaXJhbnRpcywgSW5jLjEXMBUGA1UEAxMOTWlyYW50aXMsIEluYy4wggGiMA0G
# CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQC1dnYm/c5cuueJNI13yqFmFtwmfoTK
# +fRQELz09s9MvKy2698I1L23AjvdViNv2Ris6IKiLoVZaZr9bdPQv1R4Zl77F1Eu
# FpR5RLUAKcq0j3GnfO/36jz8yrqxxmEY2fwQyE6yb5+57BmYZSgCrO/sHgAY8HIL
# 4ULpsiFje069MIVKJT/QksXUsK25k5LoMs/byxVILLo/v6jYGfq1Yhz6iuZYCgfV
# m7t7jWhj9BtWnE7ph4QFINiNSwUs58EdL0J6HFRUNWgp0is/55qMaEaEOD0jfsFu
# aXoOTayNFS3Zxcr5aA3X9X5OFlko36/iwuksqfP6lfefuOKMjbYyEdPlX+An5iyD
# V0bxW5P8ixsdx1sUzFj5loIN1FTwngKhasVf4u0TAfS+FtEJqUh18CK1aWgMRFpe
# ZZ4qck/THm03MvoOXN6TgE70Fa7Z4lt2WP4njx4WildevAwWPHDttAAuSfrOmj3U
# qjqHwpfHPopPqQILSuHXg1VK21425ENpeZMCAwEAAaOCAgMwggH/MB8GA1UdIwQY
# MBaAFGg34Ou2O/hfEYb7/mF7CIhl9E5CMB0GA1UdDgQWBBTB3ama4axmTKwVUSnj
# Hxc8KCOJqzA+BgNVHSAENzA1MDMGBmeBDAEEATApMCcGCCsGAQUFBwIBFhtodHRw
# Oi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQM
# MAoGCCsGAQUFBwMDMIG1BgNVHR8Ega0wgaowU6BRoE+GTWh0dHA6Ly9jcmwzLmRp
# Z2ljZXJ0LmNvbS9EaWdpQ2VydFRydXN0ZWRHNENvZGVTaWduaW5nUlNBNDA5NlNI
# QTM4NDIwMjFDQTEuY3JsMFOgUaBPhk1odHRwOi8vY3JsNC5kaWdpY2VydC5jb20v
# RGlnaUNlcnRUcnVzdGVkRzRDb2RlU2lnbmluZ1JTQTQwOTZTSEEzODQyMDIxQ0Ex
# LmNybDCBlAYIKwYBBQUHAQEEgYcwgYQwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3Nw
# LmRpZ2ljZXJ0LmNvbTBcBggrBgEFBQcwAoZQaHR0cDovL2NhY2VydHMuZGlnaWNl
# cnQuY29tL0RpZ2lDZXJ0VHJ1c3RlZEc0Q29kZVNpZ25pbmdSU0E0MDk2U0hBMzg0
# MjAyMUNBMS5jcnQwCQYDVR0TBAIwADANBgkqhkiG9w0BAQsFAAOCAgEAdLWZeIgm
# HLXVqoh67ptK1opXnfVK3qppXx429m33BKJ2gM80YTShuwvc/pIaSbzhy5p5g2TU
# muw/ijzucESeIH6HP6qHEuu/kNVdwWTHg71iBzO/RaCOX9acpH8/3zShTxjd0le4
# c7FhPMW3T7gf2wCqcmXyxyConO47HYK8H8AYU/0HXKQ1XI2AhBbQwk5ImC0LhyaE
# lOVY9r+ipd4YUHgeOR9Zo14V2GiUPMtr+I4M14YEnFgPdyN524tzCA9+Q5neNWVN
# iTb8o4TIkrbusAcPQ2NJgR9Fyz5H9kjuQ4jA/bAMZAnsoZvV7NLwcVXJHl76YJ+v
# SFe+zqahpHhaYPKI5XjCO1nKbthXxJsfdYP5UDKM9x51USTo/69+OYxIj6DM/ZZz
# AufovCnhfwpFp+lyY4jya+iYQ/5x0l4SRbc+FYGWVpcFao+xDt6MOjiClso+f3i1
# A1NCukjqHYWaMfBuQq7YH02h/fjqx/Y97KxDwmGrX1YzlhO3cFPOKFFh/mYBRE5f
# opKK7S2H5n6diy4ShHnPsrsCpYAdjCmM6UsvLOD02ZPyiV1Gy+98mrD4jHzwjTfL
# 7bbBvH8SeC0ewZtVBVzHXfrAn27J0vP1DibJKJafX+9mWzUAFRnTKfzbNQogM/gY
# chBE/D0I0Sa9/a0Xwy1QjmOGSZhD7Dou+bgwggbtMIIE1aADAgECAhAKgO8YS43x
# BYLRxHanlXRoMA0GCSqGSIb3DQEBCwUAMGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQK
# Ew5EaWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBU
# aW1lU3RhbXBpbmcgUlNBNDA5NiBTSEEyNTYgMjAyNSBDQTEwHhcNMjUwNjA0MDAw
# MDAwWhcNMzYwOTAzMjM1OTU5WjBjMQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGln
# aUNlcnQsIEluYy4xOzA5BgNVBAMTMkRpZ2lDZXJ0IFNIQTI1NiBSU0E0MDk2IFRp
# bWVzdGFtcCBSZXNwb25kZXIgMjAyNSAxMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
# MIICCgKCAgEA0EasLRLGntDqrmBWsytXum9R/4ZwCgHfyjfMGUIwYzKomd8U1nH7
# C8Dr0cVMF3BsfAFI54um8+dnxk36+jx0Tb+k+87H9WPxNyFPJIDZHhAqlUPt281m
# HrBbZHqRK71Em3/hCGC5KyyneqiZ7syvFXJ9A72wzHpkBaMUNg7MOLxI6E9RaUue
# HTQKWXymOtRwJXcrcTTPPT2V1D/+cFllESviH8YjoPFvZSjKs3SKO1QNUdFd2adw
# 44wDcKgH+JRJE5Qg0NP3yiSyi5MxgU6cehGHr7zou1znOM8odbkqoK+lJ25LCHBS
# ai25CFyD23DZgPfDrJJJK77epTwMP6eKA0kWa3osAe8fcpK40uhktzUd/Yk0xUvh
# DU6lvJukx7jphx40DQt82yepyekl4i0r8OEps/FNO4ahfvAk12hE5FVs9HVVWcO5
# J4dVmVzix4A77p3awLbr89A90/nWGjXMGn7FQhmSlIUDy9Z2hSgctaepZTd0ILIU
# bWuhKuAeNIeWrzHKYueMJtItnj2Q+aTyLLKLM0MheP/9w6CtjuuVHJOVoIJ/DtpJ
# RE7Ce7vMRHoRon4CWIvuiNN1Lk9Y+xZ66lazs2kKFSTnnkrT3pXWETTJkhd76CID
# BbTRofOsNyEhzZtCGmnQigpFHti58CSmvEyJcAlDVcKacJ+A9/z7eacCAwEAAaOC
# AZUwggGRMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOQ7/PIx7f391/ORcWMZUEPP
# YYzoMB8GA1UdIwQYMBaAFO9vU0rp5AZ8esrikFb2L9RJ7MtOMA4GA1UdDwEB/wQE
# AwIHgDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCDCBlQYIKwYBBQUHAQEEgYgwgYUw
# JAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBdBggrBgEFBQcw
# AoZRaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3RlZEc0
# VGltZVN0YW1waW5nUlNBNDA5NlNIQTI1NjIwMjVDQTEuY3J0MF8GA1UdHwRYMFYw
# VKBSoFCGTmh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydFRydXN0ZWRH
# NFRpbWVTdGFtcGluZ1JTQTQwOTZTSEEyNTYyMDI1Q0ExLmNybDAgBgNVHSAEGTAX
# MAgGBmeBDAEEAjALBglghkgBhv1sBwEwDQYJKoZIhvcNAQELBQADggIBAGUqrfEc
# JwS5rmBB7NEIRJ5jQHIh+OT2Ik/bNYulCrVvhREafBYF0RkP2AGr181o2YWPoSHz
# 9iZEN/FPsLSTwVQWo2H62yGBvg7ouCODwrx6ULj6hYKqdT8wv2UV+Kbz/3ImZlJ7
# YXwBD9R0oU62PtgxOao872bOySCILdBghQ/ZLcdC8cbUUO75ZSpbh1oipOhcUT8l
# D8QAGB9lctZTTOJM3pHfKBAEcxQFoHlt2s9sXoxFizTeHihsQyfFg5fxUFEp7W42
# fNBVN4ueLaceRf9Cq9ec1v5iQMWTFQa0xNqItH3CPFTG7aEQJmmrJTV3Qhtfparz
# +BW60OiMEgV5GWoBy4RVPRwqxv7Mk0Sy4QHs7v9y69NBqycz0BZwhB9WOfOu/CIJ
# nzkQTwtSSpGGhLdjnQ4eBpjtP+XB3pQCtv4E5UCSDag6+iX8MmB10nfldPF9SVD7
# weCC3yXZi/uuhqdwkgVxuiMFzGVFwYbQsiGnoa9F5AaAyBjFBtXVLcKtapnMG3VH
# 3EmAp/jsJ3FVF3+d1SVDTmjFjLbNFZUWMXuZyvgLfgyPehwJVxwC+UpX2MSey2ue
# Iu9THFVkT+um1vshETaWyQo8gmBto/m3acaP9QsuLj3FNwFlTxq25+T4QwX9xa6I
# Ls84ZPvmpovq90K8eWyG2N01c4IhSOxqt81nMYIF0DCCBcwCAQEwfTBpMQswCQYD
# VQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xQTA/BgNVBAMTOERpZ2lD
# ZXJ0IFRydXN0ZWQgRzQgQ29kZSBTaWduaW5nIFJTQTQwOTYgU0hBMzg0IDIwMjEg
# Q0ExAhAPmPPW+MwrF5Pm2YzwldzJMA0GCWCGSAFlAwQCAQUAoHwwEAYKKwYBBAGC
# NwIBDDECMAAwGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIB
# CzEOMAwGCisGAQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEII0eU6XXNxC0RxPYdwHS
# G3+SAr9JWkbYEavV62Z5LeUiMA0GCSqGSIb3DQEBAQUABIIBgFnHi23/SEFa6+uM
# PyDr2AgH5GubB5+j3j8MJOpsIMPv/oNtwTyLJhV2TkkESaakQOlpWuf9F3Rk8Fzo
# 0cR1J3+WlZPwWyWEZWVy/ngvP63ND1mIii+zXB9HEKpF7OgJqfXxP6j1ac0qFC/L
# PB3DpZpD4kTRB8dXOi8aEVglm+4u1NQySBgB975WwVKAozSn6eRpDo9cUF39JN4d
# pywSYNQN7PqZsFhDaOgSYQiowoUj5AR36EHYbdjoDi+kAwdxMnLPk/3eMTymrC83
# 7z+UQC4+MN6Ov6EWQI1GICHSE0mp967uuXd9M1b2SZpkPcGFmFBwstabuYct2ndj
# Oz+rCWK/lIiYX7sd3Ko/wuxltA2znx7J1ouNU18kQm8hRWgeouSrINf183JLfZ+5
# 1+sSiHSrbrbixrBUaIjbVe2azKO40n1c1SxIJQj0s7BNgl5dKOZ3Y4Lxvx8nlb4x
# SYjurX6KfQuR8905pvT6T3J2DEorz2oQQRzgxI7XToGVqSCQIaGCAyYwggMiBgkq
# hkiG9w0BCQYxggMTMIIDDwIBATB9MGkxCzAJBgNVBAYTAlVTMRcwFQYDVQQKEw5E
# aWdpQ2VydCwgSW5jLjFBMD8GA1UEAxM4RGlnaUNlcnQgVHJ1c3RlZCBHNCBUaW1l
# U3RhbXBpbmcgUlNBNDA5NiBTSEEyNTYgMjAyNSBDQTECEAqA7xhLjfEFgtHEdqeV
# dGgwDQYJYIZIAWUDBAIBBQCgaTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwG
# CSqGSIb3DQEJBTEPFw0yNTExMjcyMjI0MjdaMC8GCSqGSIb3DQEJBDEiBCAxXqAf
# vRwy7quAfRJg5DcXQEkL5fDlKfquKyed1fjuZzANBgkqhkiG9w0BAQEFAASCAgCl
# f2DgYVP6V0qz5AA6Qh553rx5xfYlr1aOXbT1W6I83193yFiG19ShPN3V8hwwQJSE
# ElDttePzdKW7IWL65P8pPqLV6D9RXM+qllbtz2YHZO8EpkmiXSs3ef06ojqJH3Bk
# sCTU9wBtiVcV+NBiKblhXAzMctyUmoWeK3M0nfD4gY/JOuBTaBKWm9fwYWexEb6g
# JfH1JweNiXutGAgIJqAcykdR8Ox86nsHYjhAi3p9IKmUp48mvP2XqnEiXERvmvFn
# dYbuy0IIvLCH6Leoj4GCmM1HH69gYZZNibV7LyzJVIYPRpbZfMfkCDKfHCkckq8u
# zsZVe+CCweqUAPHKxx/svJWg/We5Rp7uLtaPvsfi5awLJAwkrWPbJeosHKGUUO3a
# IL0s5AcGPGqgM+UZv6SB6GOBN/X8Uh3RRPgrWVgbcIVClHGeKIkXD5ZrP4jHTBC/
# SDyyOD4OuSOrE6ON++aMaH4UEjHDpGtNLI/rpR77f/Fi3Hx9L8UfXDYT1yg09d4J
# 2IuBGV99vZ7WJg1Q8x8Bum3dVJJ/Ln47dGNy+kh2p1p5K28aCrenJJW9Mi5N1JBX
# i2yU5IIXh5XZrdE1iEeYmq7T4L9nKUrNOuwpD62N2DVkicVQcDUZqvGU3wAlON++
# Kb3Xi1Q9zqOnehntApxyQpDoAhLWgIzXn9j2S/YmfA==
# SIG # End signature block
